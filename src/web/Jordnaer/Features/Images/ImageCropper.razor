@using MudBlazor
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@implements IAsyncDisposable

<div class="cropper-container">
    <MudText Typo="Typo.h6" Class="mb-3">Beskær dit billede</MudText>

    @if (ShowWarning)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-3">
            @WarningMessage
        </MudAlert>
    }

    <div id="@ImageCropperContainerId" style="max-width: 100%; max-height: 400px; margin-bottom: 1rem;">
        <img id="@ImageToCropId" src="@ImageDataUrl" style="max-width: 100%;" />
    </div>

    <MudText Typo="Typo.subtitle2" Class="mb-2">Sådan vil dit billede se ud:</MudText>

    <div class="preview-container mb-4" style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
        @foreach (var preview in ProfilePictureConstants.PreviewSizes)
        {
            <div style="text-align: center;">
                <MudText Typo="Typo.caption">@preview.Label (@(preview.Size)x@(preview.Size))</MudText>
                <MudPaper Elevation="2" Class="rounded-circle overflow-hidden" Style="@($"width: {preview.Size}px; height: {preview.Size}px;")">
                    <img id="@(preview.GetElementId(ComponentId))" style="width: 100%; height: 100%; object-fit: cover;" />
                </MudPaper>
            </div>
        }
    </div>

    <div class="d-flex gap-2">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="HandleSave" Disabled="IsSaving">
            @if (IsSaving)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
            }
            Gem billede
        </MudButton>
        <MudButton Variant="Variant.Outlined" OnClick="HandleCancel" Disabled="IsSaving">
            Annuller
        </MudButton>
    </div>
</div>

@code {
    [Parameter]
    public required string ImageDataUrl { get; set; }

    [Parameter]
    public bool ShowWarning { get; set; }

    [Parameter]
    public string WarningMessage { get; set; } = string.Empty;

    [Parameter]
    public bool IsSaving { get; set; }

    [Parameter]
    public EventCallback<byte[]> OnSave { get; set; }

    [Parameter]
    public EventCallback OnCancel { get; set; }

    private readonly string ComponentId = Guid.NewGuid().ToString("N");
    private string? _lastInitializedImageUrl = null;

    private string ImageCropperContainerId => $"image-cropper-container-{ComponentId}";
    private string ImageToCropId => $"image-to-crop-{ComponentId}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (_lastInitializedImageUrl != ImageDataUrl)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("imageCropper.initializeCropper", ImageToCropId, ComponentId);
                _lastInitializedImageUrl = ImageDataUrl;
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Der opstod en fejl ved initialisering af billedbeskæring: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task HandleSave()
    {
        try
        {
            // Get cropped image as base64
            var croppedImageDataUrl = await JSRuntime.InvokeAsync<string>(
                "imageCropper.getCroppedImage",
                ComponentId,
                ProfilePictureConstants.CroppedImageSize,
                ProfilePictureConstants.CroppedImageSize
            );

            // Validate the data URL
            if (string.IsNullOrEmpty(croppedImageDataUrl))
            {
                Snackbar.Add("Det beskårne billede er tomt. Prøv venligst igen.", Severity.Error);
                return;
            }

            var parts = croppedImageDataUrl.Split(',');
            if (parts.Length < 2)
            {
                Snackbar.Add("Det beskårne billede har et ugyldigt format. Prøv venligst igen.", Severity.Error);
                return;
            }

            // Convert base64 to bytes
            var base64Data = parts[1];
            byte[] bytes;
            try
            {
                bytes = Convert.FromBase64String(base64Data);
            }
            catch (FormatException)
            {
                Snackbar.Add("Det beskårne billede kunne ikke behandles. Prøv venligst igen.", Severity.Error);
                return;
            }

            await OnSave.InvokeAsync(bytes);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Der opstod en fejl: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleCancel()
    {
        await OnCancel.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_lastInitializedImageUrl is not null)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("imageCropper.destroyCropper", ComponentId);
            }
            catch
            {
                // Ignore errors during disposal
            }
        }
    }
}
