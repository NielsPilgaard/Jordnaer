@using JetBrains.Annotations
@inject IDataForsyningenClient DataForsyningenClient
@inject ILocationService LocationService
@inject IJSRuntime JsRuntime

<MudStack Spacing="3">
    @if (_isLoadingLocation)
    {
        <MudAlert Severity="Severity.Info" Dense Class="mb-2">
            <div class="d-flex align-center gap-2">
                <MudProgressCircular Size="Size.Small" Indeterminate />
                <MudText Typo="Typo.body2">Henter din placering...</MudText>
            </div>
        </MudAlert>
    }

    @* Address search with autocomplete *@
    <MudAutocomplete T="string" Value="@_addressText" SearchFunc="SearchForAddresses"
        DebounceInterval="250" MinCharacters="3" ResetValueOnEmptyText CoerceText="false" CoerceValue="false"
        ProgressIndicatorColor="Color.Info" Placeholder="Indtast adresse (f.eks. 'Park Allé 1, 8000 Aarhus')" Clearable
        ValueChanged="OnAddressSelected" AdornmentIcon="@Icons.Material.Filled.LocationOn" AdornmentColor="Color.Primary"
        Variant="Variant.Outlined" />

    @* Radius slider with value display *@
    <MudStack Spacing="1" Class="mt-3">
        <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
            <MudText Typo="Typo.body2">
                Radius:
            </MudText>
            <MudText Typo="Typo.body1" Color="Color.Default">
                <strong>@RadiusKm km</strong>
            </MudText>
        </MudStack>
        <MudSlider Value="@RadiusKm" Min="0" Max="200" Step="5" Color="Color.Primary"
            Size="Size.Medium" Class="py-2"
            ValueChanged="@(async (int newValue) => await OnRadiusChanged(newValue))" />
    </MudStack>

    @* Map *@
    <LeafletMap @ref="_mapComponent" MapId="@MapId" InitialLatitude="@InitialLatitude"
        InitialLongitude="@InitialLongitude" InitialZoom="@InitialZoom" OnLocationSelected="OnMapClicked"
        MapStyle="height: 450px; width: 100%; border-radius: 12px; border: 2px solid #e0e0e0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" />

    @* Instructions *@
    <MudAlert Severity="Severity.Info" Dense Icon="@Icons.Material.Filled.Info" Class="mt-2">
        <MudText Typo="Typo.caption">
            Klik på kortet eller søg efter en adresse for at vælge et søgeområde
        </MudText>
    </MudAlert>
</MudStack>

@code {
    private LeafletMap? _mapComponent;
    private string? _addressText;
    private bool _isLoadingLocation = false;
    private bool _hasAttemptedGeolocation = false;
    private IEnumerable<GroupMarkerData>? _previousGroups;

    [Parameter]
    public string MapId { get; set; } = $"map-search-{Guid.NewGuid()}";

    [Parameter]
    public double InitialLatitude { get; set; } = 56.0; // Center of Denmark

    [Parameter]
    public double InitialLongitude { get; set; } = 10.0; // Center of Denmark

    [Parameter]
    public int InitialZoom { get; set; } = 7;

    [Parameter]
    public int RadiusKm { get; set; } = 25;

    [Parameter]
    public EventCallback<int> RadiusKmChanged { get; set; }

    [Parameter]
    public EventCallback<(double Latitude, double Longitude, int RadiusKm, string? Address)> OnLocationSearchChanged
    {
        get;
        set;
    }

    /// <summary>
    /// Group data to display as markers on the map
    /// </summary>
    [Parameter]
    public IEnumerable<GroupMarkerData>? Groups { get; set; }

    /// <summary>
    /// When true, skips automatic geolocation on first render.
    /// Use this when restoring from cache to prevent geolocation from overriding restored state.
    /// </summary>
    [Parameter]
    public bool SkipGeolocation { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_hasAttemptedGeolocation)
        {
            _hasAttemptedGeolocation = true;

            // Wait for the map to initialize
            await WaitForMapInitializationAsync();

            if (_mapComponent?.IsInitialized == true)
            {
                // Only attempt geolocation if we're not restoring state from cache or skipping explicitly
                if (!SkipGeolocation)
                {
                    await TryGetUserLocation();
                }

                // Push initial group markers after map is initialized
                if (Groups is not null)
                {
                    _previousGroups = Groups;
                    await _mapComponent.UpdateGroupMarkersAsync(Groups);
                }
            }
        }
    }

    private async Task TryGetUserLocation()
    {
        try
        {
            _isLoadingLocation = true;
            StateHasChanged();

            var position = await JsRuntime.InvokeAsync<GeolocationPosition?>("geolocationService.getCurrentPosition");

            if (position is not null && position.Latitude != 0 && position.Longitude != 0)
            {
                // User granted permission, update map to their location
                if (_mapComponent is not null)
                {
                    await _mapComponent.CenterMapAsync(position.Latitude, position.Longitude, 10);
                    await _mapComponent.UpdateMarkerAsync(position.Latitude, position.Longitude);
                    await _mapComponent.UpdateSearchRadiusAsync(position.Latitude, position.Longitude, RadiusKm);
                }

                // Notify parent component
                await OnLocationSearchChanged.InvokeAsync((position.Latitude, position.Longitude, RadiusKm, null));
            }
            // If null or denied, map stays at default Denmark center
        }
        catch (Exception ex)
        {
            // Geolocation failed or denied - silently fall back to Denmark center
            Console.WriteLine($"Geolocation error: {ex.Message}");
        }
        finally
        {
            _isLoadingLocation = false;
            StateHasChanged();
        }
    }

    [UsedImplicitly]
    private class GeolocationPosition
    {
        public double Latitude { get; set; }
        public double Longitude { get; set; }
    }

    /// <summary>
    /// Searches for Danish addresses using DataForsyningen API
    /// </summary>
    private async Task<IEnumerable<string>> SearchForAddresses(string value, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(value) || value.Length < 3)
        {
            return [];
        }

        var searchResponse = await DataForsyningenClient.GetAddressesWithAutoComplete(value, cancellationToken);

        return searchResponse is { IsSuccessful: true, Content: not null }
        ? searchResponse.Content.Select(response => response.ToString())
        : [];
    }

    /// <summary>
    /// Called when an address is selected from autocomplete
    /// </summary>
    private async Task OnAddressSelected(string? address)
    {
        if (string.IsNullOrWhiteSpace(address))
        {
            return;
        }

        _addressText = address;

        // Get coordinates for the selected address
        var locationResult = await LocationService.GetLocationFromAddressAsync(address);

        if (locationResult is null)
        {
            return;
        }

        var lat = locationResult.Location.Y;
        var lng = locationResult.Location.X;

        // Update map
        if (_mapComponent is not null)
        {
            await _mapComponent.CenterMapAsync(lat, lng, 13);
            await _mapComponent.UpdateMarkerAsync(lat, lng);
            await _mapComponent.UpdateSearchRadiusAsync(lat, lng, RadiusKm);
        }

        // Notify parent component
        await OnLocationSearchChanged.InvokeAsync((lat, lng, RadiusKm, address));
    }

    /// <summary>
    /// Called when the map is clicked
    /// </summary>
    private async Task OnMapClicked((double Latitude, double Longitude) location)
    {
        var (lat, lng) = location;

        // Clear the address text since we're selecting a new location on the map
        _addressText = null;

        // Update marker and radius on map
        if (_mapComponent is not null)
        {
            await _mapComponent.UpdateMarkerAsync(lat, lng);
            await _mapComponent.UpdateSearchRadiusAsync(lat, lng, RadiusKm);
        }

        // Pass null for address when clicking on map (not from address search)
        await OnLocationSearchChanged.InvokeAsync((lat, lng, RadiusKm, null));
    }

    /// <summary>
    /// Called when the radius slider changes
    /// </summary>
    private async Task OnRadiusChanged(int newRadius)
    {
        RadiusKm = newRadius;
        await RadiusKmChanged.InvokeAsync(newRadius);

        // The parent will handle updating the map through the public method
    }

    /// <summary>
    /// Public method to update the search radius visualization
    /// Call this from parent when radius changes
    /// </summary>
    public async Task UpdateSearchRadiusAsync(double lat, double lng, int radiusKm, bool fitBounds = false)
    {
        if (_mapComponent is not null)
        {
            await _mapComponent.UpdateSearchRadiusAsync(lat, lng, radiusKm, fitBounds);
        }
    }

    /// <summary>
    /// Public method to update the map based on lat/long
    /// </summary>
    public async Task SetLocationAsync(double lat, double lng, int? zoom = null)
    {
        if (_mapComponent is not null)
        {
            await _mapComponent.CenterMapAsync(lat, lng, zoom);
            await _mapComponent.UpdateMarkerAsync(lat, lng);
            if (RadiusKm > 0)
            {
                await _mapComponent.UpdateSearchRadiusAsync(lat, lng, RadiusKm);
            }
        }
    }

    /// <summary>
    /// Public method to clear the location and reset the map
    /// </summary>
    public async Task ClearLocationAsync()
    {
        _addressText = null;

        // Only attempt to clear if map has been initialized by LeafletMap
        if (_mapComponent?.IsInitialized == true)
        {
            try
            {
                await _mapComponent.RemoveMarkerAsync();
                await _mapComponent.RemoveSearchRadiusAsync();
                await _mapComponent.CenterMapAsync(InitialLatitude, InitialLongitude, InitialZoom);
            }
            catch (Exception ex)
            {
                // Log but ignore errors - map might not be fully ready
                Console.WriteLine($"Map clear error: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// Public method to update group markers on the map
    /// </summary>
    public async Task UpdateGroupMarkersAsync(IEnumerable<GroupMarkerData> groups)
    {
        if (_mapComponent?.IsInitialized == true)
        {
            await _mapComponent.UpdateGroupMarkersAsync(groups);
        }
    }

    /// <summary>
    /// Public method to clear group markers from the map
    /// </summary>
    public async Task ClearGroupMarkersAsync()
    {
        if (_mapComponent?.IsInitialized == true)
        {
            await _mapComponent.ClearGroupMarkersAsync();
        }
    }

    /// <summary>
    /// Gets the current map state including view and address
    /// </summary>
    public async Task<(MapViewState? ViewState, string? AddressText)> GetMapStateAsync()
    {
        MapViewState? viewState = null;

        if (_mapComponent?.IsInitialized == true)
        {
            viewState = await _mapComponent.GetMapStateAsync();
        }

        return (viewState, _addressText);
    }

    /// <summary>
    /// Restores the map state from a previous session
    /// </summary>
    public async Task RestoreMapStateAsync(
        double markerLatitude,
        double markerLongitude,
        double viewLatitude,
        double viewLongitude,
        int zoom,
        string? addressText)
    {
        _addressText = addressText;

        // Wait for map to be initialized
        await WaitForMapInitializationAsync();

        if (_mapComponent?.IsInitialized == true)
        {
            // Restore the marker at its correct position
            await _mapComponent.UpdateMarkerAsync(markerLatitude, markerLongitude);
            await _mapComponent.UpdateSearchRadiusAsync(markerLatitude, markerLongitude, RadiusKm);

            // Restore the view to where the user was looking
            await _mapComponent.CenterMapAsync(viewLatitude, viewLongitude, zoom);

            // Note: We do NOT call OnLocationSearchChanged here because the Filter
            // has already been restored from cache in the parent component.
            // Calling it would overwrite the cached filter values.
        }
    }

    /// <summary>
    /// Helper method to wait for map initialization with polling
    /// </summary>
    private async Task WaitForMapInitializationAsync()
    {
        var attempts = 0;
        while (_mapComponent?.IsInitialized != true && attempts < 20)
        {
            await Task.Delay(50);
            attempts++;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Update group markers only when Groups parameter actually changes
        if (_mapComponent?.IsInitialized == true)
        {
            // Materialize Groups once to avoid multiple enumeration
            var groupsList = Groups?.ToList();

            // Handle when groups are cleared (set to null or empty)
            if (groupsList is null || groupsList.Count == 0)
            {
                if (_previousGroups is not null)
                {
                    _previousGroups = null;
                    await _mapComponent.ClearGroupMarkersAsync();
                }
            }
            // Handle when groups are updated
            else if (Groups != _previousGroups)
            {
                _previousGroups = Groups;
                await _mapComponent.UpdateGroupMarkersAsync(groupsList);
            }
        }
    }
}