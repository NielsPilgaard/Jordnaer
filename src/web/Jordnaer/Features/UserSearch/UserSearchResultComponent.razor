@using Jordnaer.Features.Ad
@inject IJSRuntime JsRuntime
@inject NavigationManager Navigation
@inject IAdProvider AdProvider

@implements IDisposable

<MudContainer MaxWidth="MaxWidth.Large" Class="px-0">
    <MudGrid Spacing="3" Justify="@(SearchResult.Users.Count <= 3 ? Justify.Center : Justify.FlexStart)">
        @{
            var items = GetItemsWithAds();
            var index = 0;
        }
        @foreach (var item in items)
        {
            var itemId = GetItemId(index);
            <MudItem xs="12" sm="6" md="4" lg="3" id="@itemId">
                @if (item.IsAd && item.Ad is not null)
                {
                    <AdCard Link="@item.Ad.Link" ImagePath="@item.Ad.ImagePath" ImageAlt="@item.Ad.Title"
                            PartnerId="@(item.Ad.PartnerId ?? Guid.Empty)" />
                }
                else if (item.User is not null)
                {
                    <UserCard User="@item.User" />
                }
            </MudItem>
            index++;
        }
    </MudGrid>
</MudContainer>
<MudPagination Class="mt-5 d-flex justify-center" BoundaryCount="0" MiddleCount="3"
    UserAttributes="@(new Dictionary<string, object> { ["title"] = $"Viser {Filter.PageSize} ud af {SearchResult.TotalCount} resultater." })"
    SelectedChanged="@SelectedPageChanged" Variant="Variant.Filled"
    Count="@((int)Math.Ceiling((double)SearchResult.TotalCount / Filter.PageSize))" Selected="Filter.PageNumber" />

@code {

    [Parameter]
    public required UserSearchFilter Filter { get; set; }

    [Parameter]
    public required UserSearchResult SearchResult { get; set; }

    [Parameter]
    public EventCallback<int> SelectedPageChanged { get; set; }

    private IDisposable? _locationChangingHandler;
    private List<AdData> _ads = [];
    private int _lastUserCount;
    private int _lastPageNumber;

    private record SearchResultItem
    {
        public bool IsAd { get; init; }
        public UserDto? User { get; init; }
        public AdData? Ad { get; init; }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Only refresh ads when relevant parameters change
        var currentUserCount = SearchResult?.Users?.Count ?? 0;
        var currentPageNumber = Filter?.PageNumber ?? 0;

        if (_lastUserCount != currentUserCount || _lastPageNumber != currentPageNumber)
        {
            _lastUserCount = currentUserCount;
            _lastPageNumber = currentPageNumber;
            await RefreshAdsAsync();
        }
    }

    private async Task RefreshAdsAsync()
    {
        var adCount = SearchResult?.Users?.Count > 0 ? 1 : 0;
        var result = await AdProvider.GetAdsAsync(adCount);

        _ads = result.Match(
            ads => ads,
            error => new List<AdData>() // Silently use empty list on error - ads are non-critical
        );
    }

    private List<SearchResultItem> GetItemsWithAds()
    {
        var items = new List<SearchResultItem>();

        if (_ads.Count is 0 || SearchResult.Users.Count is 0)
        {
            // No ads or no users, just return users (up to 12)
            items.AddRange(SearchResult.Users.Take(12).Select(u => new SearchResultItem { User = u }));
            return items;
        }

        // Random placement for all result counts
        // With an ad, we want 11 users + 1 ad = 12 total
        var adPosition = Random.Shared.Next(0, 12);

        var userIndex = 0;
        for (int i = 0; i <= 12; i++)
        {
            if (i == adPosition)
            {
                items.Add(new SearchResultItem { IsAd = true, Ad = _ads[0] });
            }
            else if (userIndex < SearchResult.Users.Count)
            {
                items.Add(new SearchResultItem { User = SearchResult.Users[userIndex] });
                userIndex++;
            }
        }

        return items;
    }

    private string GetItemId(int index) => $"search-item-{index}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await RestoreScrollPosition();
        }
    }

    private async Task RestoreScrollPosition()
    {
        await JsRuntime.InvokeVoidAsyncWithErrorHandling("userSearchScroll.restoreScrollPosition");
    }

    private async Task SaveScrollPosition()
    {
        await JsRuntime.InvokeVoidAsyncWithErrorHandling("userSearchScroll.saveScrollPosition");
    }

    protected override void OnInitialized()
    {
        _locationChangingHandler = Navigation
            .RegisterLocationChangingHandler(async _ => await SaveScrollPosition());
    }

    public void Dispose()
    {
        _locationChangingHandler?.Dispose();
    }
}
